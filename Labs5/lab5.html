<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Three.js Project</title>
    <style type="text/css">
        canvas {
            border: 2px black solid; /* Visual separation for the canvas */
        }
    </style>
</head>

<body>

    <h1>Fionn McGoldrick</h1>

    <!-- Include the Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        var mainColor = "rgb(230,215,255)"; // Main color for the spheres

        // Initialize the Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(mainColor); // Set background color

        // Create and position the camera
        var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Position the camera

        // Set up the WebGL renderer
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight); // Full window size
        renderer.shadowMap.enabled = true; // Enable shadow effects
        document.body.appendChild(renderer.domElement); // Add renderer to the document

        // Sphere Class Definition
        class Sphere {
            constructor(radius, color, position) {
                this.radius = radius; // Store radius for collision detection
                this.geometry = new THREE.SphereGeometry(radius, 32, 16); // Create sphere geometry
                this.material = new THREE.MeshLambertMaterial({ color: color, wireframe: true }); // Material with wireframe
                this.mesh = new THREE.Mesh(this.geometry, this.material); // Create mesh
                this.mesh.castShadow = true; // Enable shadow casting

                this.mesh.position.copy(position); // Set initial position
                scene.add(this.mesh); // Add sphere to the scene
            }

            // Movement properties
            xSpeed = 0.05; // Horizontal speed
            ySpeed = 0.05; // Vertical speed
            x_direction = 1; // Direction of movement
            gravity = -0.01; // Gravity effect
            rightBoundary = 7.2; // Right boundary limit
            leftBoundary = -7.2; // Left boundary limit
            dampingFactor = 0.8; // Bounce damping factor
            XdampingFactor = 0.999; // Horizontal damping factor

            // Update position and rotation of the sphere
            update() {
                this.ySpeed += this.gravity; // Apply gravity

                // Stop x movement if speed is too low
                if (this.xSpeed <= 0.01) {
                    this.xSpeed = 0; // Stop movement
                    this.mesh.rotation = 0; //Stops rotation
                } else {
                    this.xSpeed *= this.XdampingFactor; // Apply damping
                }

                this.mesh.rotation.x += 0.01; // Rotate around x-axis
                this.mesh.rotation.y += 0.01; // Rotate around y-axis

                // Update sphere position based on speed and direction
                this.mesh.position.x += this.xSpeed * this.x_direction;
                this.mesh.position.y += this.ySpeed;

                // Boundary collision detection
                if (this.mesh.position.x >= this.rightBoundary || this.mesh.position.x <= this.leftBoundary) {
                    this.x_direction *= -1; // Reverse horizontal direction
                }

                // Plane collision detection
                if (this.mesh.position.y <= planeTopPos) {
                    this.mesh.position.y = planeTopPos; // Keep above the plane
                    this.ySpeed *= -this.dampingFactor; // Reverse and dampen vertical speed
                }
            }

            // Check for collisions with another sphere
            checkCollision(otherSphere) {
                const dx = this.mesh.position.x - otherSphere.mesh.position.x; // Difference in x
                const dy = this.mesh.position.y - otherSphere.mesh.position.y; // Difference in y
                const distance = Math.sqrt(dx * dx + dy * dy); // Calculate distance
                const minDistance = this.radius + otherSphere.radius; // Minimum distance for collision

                // Handle collision resolution
                if (distance < minDistance) {
                    const overlap = minDistance - distance; // Calculate overlap
                    const direction = new THREE.Vector3(dx, dy, 0).normalize(); // Normalized direction vector

                    // Push spheres apart
                    this.mesh.position.x += direction.x * overlap * 0.5;
                    this.mesh.position.y += direction.y * overlap * 0.5;

                    otherSphere.mesh.position.x -= direction.x * overlap * 0.5;
                    otherSphere.mesh.position.y -= direction.y * overlap * 0.5;

                    // Simple response by reversing direction
                    this.x_direction *= -1;
                    otherSphere.x_direction *= -1;
                }
            }
        }

        // Create two Sphere instances
        const sphere = new Sphere(1, mainColor, new THREE.Vector3(0, 5, 0)); // Sphere 1
        const sphere2 = new Sphere(1, mainColor, new THREE.Vector3(3, 5, 0)); // Sphere 2

        // Create and configure a spotlight
        var spotLight = new THREE.SpotLight(0xffffff); // Create a white spotlight
        spotLight.position.set(0, 8, 0); // Position the spotlight
        spotLight.angle = Math.PI / 4; // Beam angle
        spotLight.penumbra = 0.3; // Soft edge
        spotLight.decay = 1; // Intensity decay with distance
        spotLight.distance = 50; // Maximum light distance
        spotLight.castShadow = true; // Enable shadow casting
        scene.add(spotLight); // Add spotlight to the scene

        // Create a plane to receive shadows
        const planeGeometry = new THREE.PlaneGeometry(15, 20); // Plane geometry dimensions
        const planeMaterial = new THREE.MeshStandardMaterial({ color: "rgb(255, 255, 255)", opacity: 1, transparent: false }); // Plane material
        const plane = new THREE.Mesh(planeGeometry, planeMaterial); // Create plane mesh
        plane.rotation.x = -Math.PI / 2; // Rotate plane to horizontal
        plane.position.y = 0; // Position plane at ground level
        plane.receiveShadow = true; // Enable shadow reception
        scene.add(plane); // Add plane to the scene

        // Define the top position of the plane for collision detection
        const planeTopPos = plane.position.y + 0.9;

        // Animation loop function
        function animate() {
            requestAnimationFrame(animate); // Request the next frame
            sphere.update(); // Update sphere 1
            sphere2.update(); // Update sphere 2
            sphere.checkCollision(sphere2); // Check for collision between spheres
            renderer.render(scene, camera); // Render the scene
        }

        animate(); // Start the animation loop
    </script>
</body>

</html>
