<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Three.js Project</title>
    <style type="text/css">
        canvas {
            border: 2px black solid; /* Add a border around the canvas for visual separation */
        }
    </style>
</head>

<body>

    <h1>Fionn McGoldrick</h1>

    <!-- Include the Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        var mainColor = "rgb(230,215,255)"; // Define a main color variable for the sphere

        // Create a new Three.js scene
        const scene = new THREE.Scene(); 
        scene.background = new THREE.Color(mainColor); // Set the background color of the scene

        // Create and configure a camera
        var camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Position the camera at (0, 2, 5) for a good view of the sphere

        // Create a WebGL renderer
        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the renderer to fill the window
        renderer.shadowMap.enabled = true; // Enable shadow maps for realistic shadow effects
        document.body.appendChild(renderer.domElement); // Append the renderer's canvas to the document body

        // Sphere Class Definition
        class Sphere {
            constructor(radius, color, position) {
                // Create a sphere geometry and material
                this.geometry = new THREE.SphereGeometry(radius, 32, 16); // Create the sphere geometry with specified radius and detail
                this.material = new THREE.MeshLambertMaterial({ color: color, wireframe: false }); // Create a Lambert material for lighting effects
                this.mesh = new THREE.Mesh(this.geometry, this.material); // Create a mesh from the geometry and material
                this.mesh.castShadow = true; // Enable the sphere to cast shadows on other objects

                // Set the initial position of the sphere
                this.mesh.position.copy(position); // Set the position based on the input parameter

                // Add the sphere mesh to the scene
                scene.add(this.mesh);

                // Define movement properties for the sphere
                this.xSpeed = 0.03; // Speed of the sphere's movement along the x-axis
                this.direction = 1; // Direction of movement: 1 for right, -1 for left
                this.rightBoundary = 7.8; // Right boundary for the sphere's movement
                this.leftBoundary = -7.8; // Left boundary for the sphere's movement
            }

            // Method to update the sphere's position and rotation
            update() {
                // Animate the rotation of the sphere
                this.mesh.rotation.x += 0.01; // Rotate the sphere around the X-axis
                this.mesh.rotation.y += 0.01; // Rotate the sphere around the Y-axis

                // Move the sphere along the X-axis based on speed and direction
                this.mesh.position.x += this.xSpeed * this.direction;

                // Check for collisions with the defined boundaries
                if (this.mesh.position.x >= this.rightBoundary || this.mesh.position.x <= this.leftBoundary) {
                    this.direction *= -1; // Flip direction when hitting a boundary
                }
            }
        }

        // Create a new Sphere instance
        const sphere = new Sphere(1, mainColor, new THREE.Vector3(0, 1.7, 0)); // Create a sphere positioned slightly above the ground plane

        // Create a spotlight to illuminate the scene
        var spotLight = new THREE.SpotLight(0xffffff); // Create a white spotlight
        spotLight.position.set(0, 5, 5); // Position the spotlight above the sphere
        spotLight.angle = Math.PI / 4; // Set the angle of the spotlight's beam
        spotLight.penumbra = 0.3; // Soft edge of the light beam
        spotLight.decay = 1; // Rate at which the light intensity decreases with distance
        spotLight.distance = 50; // Maximum distance the light can reach
        spotLight.castShadow = true; // Enable the spotlight to cast shadows
        scene.add(spotLight); // Add the spotlight to the scene

        // Create a plane to receive shadows
        const planeGeometry = new THREE.PlaneGeometry(10, 10); // Create a plane geometry with specified width and height
        const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.5 }); // Create a material for the plane that will receive shadows
        const plane = new THREE.Mesh(planeGeometry, planeMaterial); // Create a mesh using the plane geometry and material
        plane.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
        plane.position.y = 0; // Position the plane at ground level
        plane.receiveShadow = true; // Enable the plane to receive shadows from the sphere
        scene.add(plane); // Add the plane to the scene

        // Animation Loop Function
        function animate() {
            requestAnimationFrame(animate); // Request the next frame for animation
            sphere.update(); // Call the update method of the sphere to update its position and rotation
            renderer.render(scene, camera); // Render the scene from the perspective of the camera
        }

        animate(); // Start the animation loop
    </script>
</body>

</html>
